//
// B F B S . C P P
//
// Big Float Basic Statistics
//
// bfbs.cpp last updated on Sun Dec 21 20:46:29 2025 by O.H. as 0v5
//

//
// requires the following libraries; -
//  GMP (GNU Multiple Precision Arithmetic Library)
//  MPFR (Multiple Precision Floating-Point Reliable Library)
//
// On Ubuntu make sure the library code is installed with; -
//  sudo apt install libgmp-dev libmpfr-dev
// On MacOS one method to provide the library code is with homebrew; -
//  brew install gmp
//  brew install mpfr
//
// Compile on Ubuntu with; -
//  g++ -Wall -pedantic -Wextra -std=c++17 -o bfbs_cpp bfbs.cpp -lmpfr -lgmp
// Compile on MacOS (homebrew library code) with; -
//  g++ -Wall -pedantic -Wextra -std=c++17 -I /opt/homebrew/include/ -o bfbs_cpp bfbs.cpp -L /opt/homebrew/lib/ -lmpfr -lgmp
//
// Run with; -
//  ./bfbs_cpp data1.csv data2.csv --precision 512 --digits 20 --header
//
// Usage is; -
//  Usage: ./bfbs_cpp file1.csv [file2.csv ...] [--header] [--precision N] [--digits N]
//

//
// Originally this code was generated by ChatGPT from the starting prompt; -
//
// Please write a c++ program that reads one or more comma separated value
// data files containing one or more columns of numbers and calculates the
// min, median, mean, max, range, sum, sample variance and sample standard
// deviation for each column using an arbitrary-precision floating point
// arithmetic package and prints out the results for each column in each file.
// Ensure that the program can handle leading spaces on numbers, blank rows
// in files and comment lines beginning with a hash. Allow the calculation
// precision and number of digits output when printing the results to be
// optionally controlled by the user from the command line. Also allow the
// user to optionally specify that the first row is a header of column names
// instead of numbers.
//

//
// 0v5 Minor change to help output and elapsed time message
// 0v4 Fixed compile and output execution time to uSec resolution
// 0v3 Added execution time output
// 0v2 Added --quiet option to suppress version info and increase output digits to 64
//

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <algorithm>
#include <iomanip>
#include <mpfr.h>
#include <time.h>   // clock_gettime()

using namespace std;

#define PROGRAM_NAME __FILE__
#define PROGRAM_VERSION "0v5"

// RAII Wrapper for mpfr_t
class MpfrFloat {
public:
    mpfr_t value;

    MpfrFloat(int precision = 256) {
        mpfr_init2(value, precision);
    }

    MpfrFloat(const MpfrFloat& other) {
        mpfr_init2(value, mpfr_get_prec(other.value));
        mpfr_set(value, other.value, MPFR_RNDN);
    }

    MpfrFloat& operator=(const MpfrFloat& other) {
        if (this != &other) {
            mpfr_set(value, other.value, MPFR_RNDN);
        }
        return *this;
    }

    ~MpfrFloat() {
        mpfr_clear(value);
    }

    bool operator<(const MpfrFloat& other) const {
        return mpfr_less_p(value, other.value);
    }

    bool operator>(const MpfrFloat& other) const {
        return mpfr_greater_p(value, other.value);
    }
};

struct Options {
    int precision = 256;
    int digits = 64;
    bool hasHeader = false;
    bool quiet = false;
    bool help = false;
    vector<string> files;
};

Options parseArgs(int argc, char* argv[]) {
    Options opts;
    for (int i = 1; i < argc; ++i) {
        string arg = argv[i];
        if (arg == "--precision" && i + 1 < argc) {
            opts.precision = stoi(argv[++i]);
        } else if (arg == "--digits" && i + 1 < argc) {
            opts.digits = stoi(argv[++i]);
        } else if (arg == "--header") {
            opts.hasHeader = true;
        } else if (arg == "--quiet") {
            opts.quiet = true;
        } else if (arg == "--help") {
            opts.help = true;
        } else {
            opts.files.push_back(arg);
        }
    }
    if (opts.files.empty() || opts.help) {
        cerr << "Usage:" << endl;
        cerr << argv[0];    // program name
        cerr << " file1.csv [file2.csv ...] [--help] [--quiet] [--header] [--precision N] [--digits N]\n";
        exit(1);
    }
    return opts;
}

void printBanner(const Options& opts) {
    if( ! opts.quiet ) {
        cout << PROGRAM_NAME << " version " << PROGRAM_VERSION << endl;
        cout << "Compiler version: " << __VERSION__ << endl;

        cout << "MPFR version: " << mpfr_get_version() << endl;
        cout << "GMP version:  " << gmp_version << endl;
    }
    cout << "Using " << opts.precision << " bits Calculation precision ";
    cout << "and " << opts.digits << " digits Output precision ";
    cout << "with Rounding mode: MPFR_RNDN (round to nearest)" << endl;
    cout << endl;
}

int readCSV(const string& filename, vector<vector<MpfrFloat>>& columns, vector<string>& headers, bool hasHeader, int precision) {
    ifstream file(filename);
    if (!file) {
        cerr << "Error: Cannot open file: " << filename << endl;
        return(1);  // failure due to file open error
    }

    string line;
    bool firstLine = true;

    while (getline(file, line)) {
        line.erase(0, line.find_first_not_of(" \t\r\n"));
        line.erase(line.find_last_not_of(" \t\r\n") + 1);

        if (line.empty() || line[0] == '#') continue;

        stringstream ss(line);
        string cell;
        vector<string> cells;
        while (getline(ss, cell, ',')) {
            size_t start = cell.find_first_not_of(" \t");
            cells.push_back(start != string::npos ? cell.substr(start) : "");
        }

        if (firstLine && hasHeader) {
            headers = cells;
            firstLine = false;
            continue;
        }

        if (columns.size() < cells.size()) {
            columns.resize(cells.size());
        }

        for (size_t i = 0; i < cells.size(); ++i) {
            MpfrFloat val(precision);
            if (mpfr_set_str(val.value, cells[i].c_str(), 10, MPFR_RNDN) != 0) {    // base 10 i.e. decimal is assumed
                cerr << "Invalid number: " << cells[i] << " in file " << filename << endl;
                exit(1);
            }
            columns[i].push_back(val);
        }

        firstLine = false;
    }
    return(0);  // success
}

vector<MpfrFloat> sortColumn(const vector<MpfrFloat>& col) {
    vector<MpfrFloat> sorted = col;
    sort(sorted.begin(), sorted.end());
    return sorted;
}

void computeStats(const vector<MpfrFloat>& col, int precision, int base, int digits, const string& name) {
    size_t n = col.size();
    if (n == 0) return;

    mpfr_t sum, mean, minVal, maxVal, range, var, stddev, temp, diff, median;
    mpfr_inits2(precision, sum, mean, minVal, maxVal, range, var, stddev, temp, diff, median, (mpfr_ptr) nullptr);

    mpfr_set(sum, col[0].value, MPFR_RNDN);
    mpfr_set(minVal, col[0].value, MPFR_RNDN);
    mpfr_set(maxVal, col[0].value, MPFR_RNDN);

    for (size_t i = 1; i < n; ++i) {
        mpfr_add(sum, sum, col[i].value, MPFR_RNDN);
        if (mpfr_less_p(col[i].value, minVal)) mpfr_set(minVal, col[i].value, MPFR_RNDN);
        if (mpfr_greater_p(col[i].value, maxVal)) mpfr_set(maxVal, col[i].value, MPFR_RNDN);
    }

    mpfr_set_ui(temp, n, MPFR_RNDN);
    mpfr_div(mean, sum, temp, MPFR_RNDN);
    mpfr_sub(range, maxVal, minVal, MPFR_RNDN);

    // Sample variance
    mpfr_set_zero(var, 1);
    for (const auto& val : col) {
        mpfr_sub(diff, val.value, mean, MPFR_RNDN);
        mpfr_mul(diff, diff, diff, MPFR_RNDN);
        mpfr_add(var, var, diff, MPFR_RNDN);
    }
    if (n > 1) {
        mpfr_set_ui(temp, n - 1, MPFR_RNDN);
        mpfr_div(var, var, temp, MPFR_RNDN);
    }

    mpfr_sqrt(stddev, var, MPFR_RNDN);

    // Median
    vector<MpfrFloat> sorted = sortColumn(col);
    if (n % 2 == 1) {
        mpfr_set(median, sorted[n / 2].value, MPFR_RNDN);
    } else {
        mpfr_add(median, sorted[n / 2 - 1].value, sorted[n / 2].value, MPFR_RNDN);
        mpfr_div_ui(median, median, 2, MPFR_RNDN);
    }

    // Output
    cout << "Column: " << name << endl;
    cout << "  Count            : " << n << endl;
    cout << fixed << setprecision(digits);
    cout << "  Minimum          : "; mpfr_out_str(stdout, base, digits, minVal, MPFR_RNDN); cout << endl;
    cout << "  Mean             : "; mpfr_out_str(stdout, base, digits, mean, MPFR_RNDN); cout << endl;
    cout << "  Median           : "; mpfr_out_str(stdout, base, digits, median, MPFR_RNDN); cout << endl;
    cout << "  Maximum          : "; mpfr_out_str(stdout, base, digits, maxVal, MPFR_RNDN); cout << endl;
    cout << "  Range            : "; mpfr_out_str(stdout, base, digits, range, MPFR_RNDN); cout << endl;
    cout << "  Sum              : "; mpfr_out_str(stdout, base, digits, sum, MPFR_RNDN); cout << endl;
    cout << "  Sample Variance  : "; mpfr_out_str(stdout, base, digits, var, MPFR_RNDN); cout << endl;
    cout << "  Sample Std. Dev. : "; mpfr_out_str(stdout, base, digits, stddev, MPFR_RNDN); cout << endl;
    cout << endl;

    mpfr_clears(sum, mean, minVal, maxVal, range, var, stddev, temp, diff, median, (mpfr_ptr) nullptr);
}

int main(int argc, char* argv[]) {
    int time_ok;
    int result_flag = 0;
    double  elapsed_wall_clock_time;
    struct timespec  start_time;
    struct timespec  finish_time;

    time_ok = (clock_gettime(CLOCK_MONOTONIC, &start_time) == 0);
    Options opts = parseArgs(argc, argv);
    printBanner(opts);

    for (const auto& file : opts.files) {
        cout << "Processing file: " << file << endl;
        vector<vector<MpfrFloat>> columns;
        vector<string> headers;

        if ( readCSV(file, columns, headers, opts.hasHeader, opts.precision ) != 0 ) {
            result_flag |= 1;   // remember there was a failure
            continue;   // failure so proceed to next file if there is one
        }

        for (size_t i = 0; i < columns.size(); ++i) {
            string name = (opts.hasHeader && i < headers.size()) ? headers[i] : "Column " + to_string(i + 1);
            computeStats(columns[i], opts.precision, 10, opts.digits, name);    // base 10 - i.e. decimal output
        }
    }

    if( ! opts.quiet && time_ok && ( clock_gettime(CLOCK_MONOTONIC, &finish_time ) == 0 )) {
        elapsed_wall_clock_time = (double)( finish_time.tv_sec - start_time.tv_sec ) +
            ( double )( finish_time.tv_nsec - start_time.tv_nsec ) * (double)(1.0e-9);
        printf( "%s (c++ executable) time taken: %9.6lf [sec]\n", argv[0], elapsed_wall_clock_time );
    }
    return result_flag;
}
